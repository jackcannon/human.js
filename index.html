<!doctype html>
<html>
  <head>
    <title>Human.js</title>
    <link rel="icon" href="img/logo-smaller.png" type="image/png">
    <link href='http://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/main.css">
  </head>
  <body>
    <canvas id="display"></canvas>
    <div id="controls">
      <textarea id="input"></textarea>
      <div id="buttons">
        <input type="button" value="Go" id="go"></input>
        <input type="button" value="Clear" id="clear"></input>
      </div>
    </div>

    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="js/async.js"></script>
    <script src="http://cloud.github.com/downloads/processing-js/processing-js/processing-1.4.1.min.js"></script>
    <script src="js/human.js"></script>

    <script>
      var box = [];

      var John = new Human({
        name: 'John',
        gender: 'male',
        x: -100,
        y: 0
      });
      var Jane = new Human({
        name: 'Jane',
        gender: 'female',
        orientation: 'left',
        x: 100,
        y: 0
      });

      var colors = {
        male: {
          light: [150, 150, 255],
          dark: [100, 100, 255]
        },
        female: {
          light: [255, 175, 175],
          dark: [255, 125, 125]
        }
      };

      function doProcessing(processing) {

        processing.setup = function() {
          font = processing.createFont('Ubuntu');
          processing.textFont(font, 18);
          processing.frameRate(12);

          processing.size($('#display').width(), $('#display').height());
          processing.background(255);
        };

        processing.draw = function () {
          processing.size($('#display').width(), $('#display').height());
          processing.background(255);

          var centreX = processing.width / 2 - 20;
          var centreY = processing.height / 2 + 75;

          function grid(spacing, color) { //color is grayscale between 0 and 255 only
            if(!spacing) var spacing = 50;
            if(!color) {
              processing.fill(200 , 200 , 200);
              processing.stroke(200 , 200 , 200);
            } else {
              processing.fill(color , color , color);
              processing.stroke(color , color , color);
            }
            processing.strokeWeight(1);
            var pW = processing.width;
            var pH = processing.height;
            for(var hor = 1; hor < Math.ceil(pW / spacing); hor++) {
              processing.line((hor * spacing), 0, (hor * spacing), pH);
            }
            for(var ver = 1; ver < Math.ceil(pH / spacing); ver++) {
              processing.line(0, (ver * spacing), pW, (ver * spacing));
            }
          };

          function setColor(gender, light) {
            processing.fill(colors[gender][light][0], colors[gender][light][1] , colors[gender][light][2]);
            processing.stroke(colors[gender][light][0], colors[gender][light][1] , colors[gender][light][2]);
          };

          function drawFloor() {
            processing.fill(230 , 230 , 230);
            processing.stroke(230 , 230 , 230);
            processing.strokeWeight(3);
            processing.line(0, centreY + 60, processing.width, centreY + 60);
          };

          function crosshair() {
            processing.fill(128 , 128 , 128);
            processing.stroke(128 , 128 , 128);
            processing.strokeWeight(1);
            var shift = -2;
            processing.line(centreX + shift, centreY - 10 + shift, centreX + shift, centreY + 10 + shift);
            processing.line(centreX - 10 + shift, centreY + shift, centreX + 10 + shift, centreY + shift);
          };

          function drawPoint(x, y, gender) { //dont apply centreX/centreY, do apply obj.x/obj.y beforehand
            setColor(gender, 'light');
            processing.strokeWeight(1);

            var pointX = centreX + x - 2;
            var pointY = centreY + y - 2;

            processing.ellipse(pointX, pointY, 4, 4);
          };

          function drawLine(x1, y1, x2, y2, gender) {
            setColor(gender, 'dark');
            processing.strokeWeight(2);
            processing.line(centreX + x1 - 2, centreY + y1 - 2, centreX + x2 - 2, centreY + y2 - 2);
          };

          function text(x, y, text, gender, type) { // type == 'header' || 'speech'
            setColor(gender, 'dark');
            if(type == 'header') {
              processing.textFont(font, 14);
            } else if (type == 'speech') {
              processing.textFont(font, 11);
            }

            processing.textAlign('CENTER', 'CENTER');
            var textWidth = processing.textWidth(text);
            processing.text( text , centreX + x - (textWidth / 2) - 2 , centreY + y - 2 );
          };

          // grid(50, 240);
          // crosshair();
          drawFloor();

          for (var obj in box) {
            for(var p in box[obj].points) {
              var point = box[obj].points[p];
              var bp = box[obj].getCoor(p);
              for(var co in point.connects) {
                var ip = box[obj].getCoor(point.connects[co]);
                drawLine(bp.x, bp.y, ip.x, ip.y, box[obj].gender);
              }
            }

            for(var p in box[obj].points) {
              var ip = box[obj].getCoor(p);
              drawPoint(ip.x, ip.y, box[obj].gender);
            }

            //do text
            var crown = box[obj].getCoor('crown');
            text(crown.x, crown.y - 30, box[obj].name, box[obj].gender, 'header');
            text(crown.x, crown.y - 15, box[obj].saying, box[obj].gender, 'speech');
          }
        }
      }


      var canvas = document.getElementById("display");
      var processingInstance = new Processing(canvas, doProcessing);

      var execute = function () {
        $('#go').attr('disabled', 'disabled');
        setTimeout(function () {
          $('#go').attr('disabled', false);
        }, 1000);

        return (box.length > 0) ? function() {
          var stuff = eval($('#input').val());
          // if(stuff) console.log(stuff);
        }.bind(box[0])() : null;
      };

      $('#go').click(execute);

      $('#clear').click(function () {
        $('#clear').attr('disabled', 'disabled');
        setTimeout(function () {
          $('#clear').attr('disabled', false);
        }, 500);

        $('#input').val('');
      })

      // $("#input, #display").hover(
      //   function () {
      //     $('#input').css({"border-top": "2px dashed rgb(65, 65, 255)"});
      //   },
      //   function () {
      //     $('#input').css({"border-top": "2px dashed rgb(100, 100, 255)"});
      //   }
      // );

      $('#input').keydown(function (e) {
        if (e.keyCode == 13 && e.shiftKey) {
          execute();
          e.preventDefault();
        }
        if (e.keyCode == 9) {
          // $('#input').val($('#input').val() + '  ');
          // console.log($('#input').caret().start);
          e.preventDefault();
        }
      });


      var putHumansInBox = function() {
        for(var v in window) {
          if(window[v] instanceof Human && ($.inArray(window[v], box) === -1)) {
            window[v].universe = box;
            box.push(window[v]);
          }
        }
      };
      putHumansInBox();
      var boxLoop = setInterval(putHumansInBox, 500);

    </script>

  </body>
</html>